//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.1.3
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord, BebopJson, BebopTypeGuard, Guid, GuidMap } from "bebop";

export const BEBOP_SCHEMA = new Uint8Array ([
3, 17, 0, 0, 0, 85, 115, 101, 114, 0, 2, 0, 5, 0, 0, 0, 2,
110, 97, 109, 101, 0, 245, 255, 255, 255, 0, 1, 117, 105,
100, 0, 245, 255, 255, 255, 0, 2, 83, 101, 115, 115, 105,
111, 110, 77, 101, 109, 98, 101, 114, 82, 111, 108, 101,
0, 4, 0, 251, 255, 255, 255, 0, 4, 0, 0, 0, 2, 67, 82, 69,
65, 84, 79, 82, 0, 0, 1, 0, 0, 0, 77, 69, 77, 66, 69, 82,
0, 0, 2, 0, 0, 0, 83, 101, 115, 115, 105, 111, 110, 77,
101, 109, 98, 101, 114, 0, 1, 0, 0, 9, 0, 0, 0, 0, 2, 117,
115, 101, 114, 0, 0, 0, 0, 0, 0, 114, 111, 108, 101, 0, 1,
0, 0, 0, 0, 72, 101, 108, 108, 111, 82, 101, 113, 117,
101, 115, 116, 0, 2, 0, 5, 0, 0, 0, 2, 110, 97, 109, 101,
0, 245, 255, 255, 255, 0, 1, 117, 105, 100, 0, 245, 255,
255, 255, 0, 2, 83, 101, 115, 115, 105, 111, 110, 67, 114,
101, 97, 116, 101, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 83, 101,
115, 115, 105, 111, 110, 68, 101, 108, 101, 116, 101, 0,
1, 0, 0, 0, 0, 0, 0, 1, 0, 83, 101, 115, 115, 105, 111,
110, 74, 111, 105, 110, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1, 105,
100, 0, 245, 255, 255, 255, 0, 83, 101, 115, 115, 105,
111, 110, 76, 101, 97, 118, 101, 0, 1, 0, 0, 0, 0, 0, 0,
1, 0, 83, 101, 115, 115, 105, 111, 110, 71, 101, 116, 0,
1, 0, 0, 0, 0, 0, 0, 1, 0, 67, 117, 114, 114, 101, 110,
116, 83, 111, 110, 103, 86, 101, 114, 115, 101, 0, 1, 0,
0, 5, 0, 0, 0, 0, 2, 115, 111, 110, 103, 72, 97, 115, 104,
0, 245, 255, 255, 255, 0, 118, 101, 114, 115, 101, 73,
100, 120, 0, 254, 255, 255, 255, 0, 67, 111, 109, 109, 97,
110, 100, 0, 3, 0, 5, 0, 0, 0, 7, 1, 3, 0, 0, 0, 2, 4, 0,
0, 0, 3, 5, 0, 0, 0, 4, 6, 0, 0, 0, 5, 7, 0, 0, 0, 6, 8,
0, 0, 0, 7, 9, 0, 0, 0, 73, 110, 102, 111, 77, 101, 115,
115, 97, 103, 101, 0, 1, 0, 0, 4, 0, 0, 0, 0, 1, 116, 101,
120, 116, 0, 245, 255, 255, 255, 0, 69, 114, 114, 111,
114, 77, 101, 115, 115, 97, 103, 101, 0, 1, 0, 0, 5, 0, 0,
0, 0, 2, 99, 111, 100, 101, 0, 254, 255, 255, 255, 0, 116,
101, 120, 116, 0, 245, 255, 255, 255, 0, 72, 101, 108,
108, 111, 82, 101, 115, 112, 111, 110, 115, 101, 0, 1, 0,
0, 4, 0, 0, 0, 0, 1, 117, 105, 100, 0, 245, 255, 255, 255,
0, 83, 101, 115, 115, 105, 111, 110, 68, 101, 116, 97,
105, 108, 115, 0, 1, 0, 0, 16, 0, 0, 0, 0, 3, 105, 100, 0,
245, 255, 255, 255, 0, 101, 120, 112, 105, 114, 101, 115,
0, 243, 255, 255, 255, 0, 109, 101, 109, 98, 101, 114,
115, 0, 242, 255, 255, 255, 0, 2, 0, 0, 0, 0, 77, 97, 114,
107, 83, 111, 110, 103, 86, 101, 114, 115, 101, 0, 1, 0,
0, 5, 0, 0, 0, 0, 2, 115, 111, 110, 103, 72, 97, 115, 104,
0, 245, 255, 255, 255, 0, 118, 101, 114, 115, 101, 73,
100, 120, 0, 254, 255, 255, 255, 0, 77, 101, 115, 115, 97,
103, 101, 0, 3, 0, 9, 0, 0, 0, 5, 1, 11, 0, 0, 0, 2, 12,
0, 0, 0, 3, 13, 0, 0, 0, 4, 14, 0, 0, 0, 5, 15, 0, 0, 0,
0, 0, 0, 0
]);

export interface IUser extends BebopRecord {

  name?: string;

  uid?: string;
}

export class User implements IUser {
  public name?: string;
  public uid?: string;

  constructor(record: IUser) {
    this.name = record.name;
    this.uid = record.uid;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return User.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IUser): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    User.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link User}.
   */
  public static validateCompatibility(record: IUser): void {
    if (record.name !== undefined) {
      BebopTypeGuard.ensureString(record.name)
    }
    if (record.uid !== undefined) {
      BebopTypeGuard.ensureString(record.uid)
    }
  }

  /**
   * Unsafely creates an instance of {@link User} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IUser {
      return new User(record);
  }

  /**
   * Creates a new {@link User} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IUser {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`User.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    User.validateCompatibility(parsed);
    return User.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return User.encode(this);
  }

  public static encode(record: IUser): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    User.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IUser, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length;
    if (record.name !== undefined) {
      view.writeByte(1);
      view.writeString(record.name);
    }
    if (record.uid !== undefined) {
      view.writeByte(2);
      view.writeString(record.uid);
    }
    view.writeByte(0);
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IUser {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return User.readFrom(view);
  }

  public static readFrom(view: BebopView): IUser {
    let message: IUser = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return new User(message);

        case 1:
          message.name = view.readString();
          break;

        case 2:
          message.uid = view.readString();
          break;

        default:
          view.index = end;
          return new User(message);
      }
    }
  }
}


export enum SessionMemberRole {

  Creator = 1,

  Member = 2,
}


export interface ISessionMember extends BebopRecord {

  readonly user: IUser;

  readonly role: SessionMemberRole;
}

export class SessionMember implements ISessionMember {
  public readonly user: IUser;
  public readonly role: SessionMemberRole;

  constructor(record: ISessionMember) {
    this.user = record.user;
    this.role = record.role;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return SessionMember.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ISessionMember): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    SessionMember.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link SessionMember}.
   */
  public static validateCompatibility(record: ISessionMember): void {
    User.validateCompatibility(record.user);
    BebopTypeGuard.ensureEnum(record.role, SessionMemberRole);
  }

  /**
   * Unsafely creates an instance of {@link SessionMember} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ISessionMember {
      record.user = User.unsafeCast(record.user);
      return new SessionMember(record);
  }

  /**
   * Creates a new {@link SessionMember} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ISessionMember {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`SessionMember.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    SessionMember.validateCompatibility(parsed);
    return SessionMember.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return SessionMember.encode(this);
  }

  public static encode(record: ISessionMember): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    SessionMember.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ISessionMember, view: BebopView): number {
    const before = view.length;
    User.encodeInto(record.user, view)
    view.writeUint32(record.role);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ISessionMember {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return SessionMember.readFrom(view);
  }

  public static readFrom(view: BebopView): ISessionMember {
    let field0: IUser;
    field0 = User.readFrom(view);
    let field1: SessionMemberRole;
    field1 = view.readUint32() as SessionMemberRole;
    let message: ISessionMember = {
      user: field0,
      role: field1,
    };
    return new SessionMember(message);
  }
}


export interface IHelloRequest extends BebopRecord {

  name?: string;

  uid?: string;
}

export class HelloRequest implements IHelloRequest {
  public readonly discriminator: number = 1 as 1;
  public static readonly discriminator: number = 1 as 1;
  public name?: string;
  public uid?: string;

  constructor(record: IHelloRequest) {
    this.name = record.name;
    this.uid = record.uid;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return HelloRequest.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IHelloRequest): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    HelloRequest.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link HelloRequest}.
   */
  public static validateCompatibility(record: IHelloRequest): void {
    if (record.name !== undefined) {
      BebopTypeGuard.ensureString(record.name)
    }
    if (record.uid !== undefined) {
      BebopTypeGuard.ensureString(record.uid)
    }
  }

  /**
   * Unsafely creates an instance of {@link HelloRequest} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IHelloRequest {
      return new HelloRequest(record);
  }

  /**
   * Creates a new {@link HelloRequest} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IHelloRequest {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`HelloRequest.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    HelloRequest.validateCompatibility(parsed);
    return HelloRequest.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return HelloRequest.encode(this);
  }

  public static encode(record: IHelloRequest): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloRequest.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloRequest, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length;
    if (record.name !== undefined) {
      view.writeByte(1);
      view.writeString(record.name);
    }
    if (record.uid !== undefined) {
      view.writeByte(2);
      view.writeString(record.uid);
    }
    view.writeByte(0);
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloRequest {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloRequest.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloRequest {
    let message: IHelloRequest = {};
    const length = view.readMessageLength();
    const end = view.index + length;
    while (true) {
      switch (view.readByte()) {
        case 0:
          return new HelloRequest(message);

        case 1:
          message.name = view.readString();
          break;

        case 2:
          message.uid = view.readString();
          break;

        default:
          view.index = end;
          return new HelloRequest(message);
      }
    }
  }
}


export interface ISessionCreate extends BebopRecord {
}

export class SessionCreate implements ISessionCreate {
  public readonly discriminator: number = 2 as 2;
  public static readonly discriminator: number = 2 as 2;

  constructor(record: ISessionCreate) {
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return SessionCreate.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ISessionCreate): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    SessionCreate.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link SessionCreate}.
   */
  public static validateCompatibility(record: ISessionCreate): void {

  }

  /**
   * Unsafely creates an instance of {@link SessionCreate} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ISessionCreate {
      return new SessionCreate(record);
  }

  /**
   * Creates a new {@link SessionCreate} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ISessionCreate {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`SessionCreate.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    SessionCreate.validateCompatibility(parsed);
    return SessionCreate.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return SessionCreate.encode(this);
  }

  public static encode(record: ISessionCreate): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    SessionCreate.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ISessionCreate, view: BebopView): number {
    const before = view.length;

    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ISessionCreate {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return SessionCreate.readFrom(view);
  }

  public static readFrom(view: BebopView): ISessionCreate {
    let message: ISessionCreate = {
    };
    return new SessionCreate(message);
  }
}


export interface ISessionDelete extends BebopRecord {
}

export class SessionDelete implements ISessionDelete {
  public readonly discriminator: number = 3 as 3;
  public static readonly discriminator: number = 3 as 3;

  constructor(record: ISessionDelete) {
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return SessionDelete.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ISessionDelete): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    SessionDelete.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link SessionDelete}.
   */
  public static validateCompatibility(record: ISessionDelete): void {

  }

  /**
   * Unsafely creates an instance of {@link SessionDelete} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ISessionDelete {
      return new SessionDelete(record);
  }

  /**
   * Creates a new {@link SessionDelete} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ISessionDelete {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`SessionDelete.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    SessionDelete.validateCompatibility(parsed);
    return SessionDelete.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return SessionDelete.encode(this);
  }

  public static encode(record: ISessionDelete): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    SessionDelete.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ISessionDelete, view: BebopView): number {
    const before = view.length;

    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ISessionDelete {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return SessionDelete.readFrom(view);
  }

  public static readFrom(view: BebopView): ISessionDelete {
    let message: ISessionDelete = {
    };
    return new SessionDelete(message);
  }
}


export interface ISessionJoin extends BebopRecord {

  readonly id: string;
}

export class SessionJoin implements ISessionJoin {
  public readonly discriminator: number = 4 as 4;
  public static readonly discriminator: number = 4 as 4;
  public readonly id: string;

  constructor(record: ISessionJoin) {
    this.id = record.id;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return SessionJoin.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ISessionJoin): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    SessionJoin.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link SessionJoin}.
   */
  public static validateCompatibility(record: ISessionJoin): void {
    BebopTypeGuard.ensureString(record.id)
  }

  /**
   * Unsafely creates an instance of {@link SessionJoin} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ISessionJoin {
      return new SessionJoin(record);
  }

  /**
   * Creates a new {@link SessionJoin} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ISessionJoin {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`SessionJoin.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    SessionJoin.validateCompatibility(parsed);
    return SessionJoin.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return SessionJoin.encode(this);
  }

  public static encode(record: ISessionJoin): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    SessionJoin.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ISessionJoin, view: BebopView): number {
    const before = view.length;
    view.writeString(record.id);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ISessionJoin {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return SessionJoin.readFrom(view);
  }

  public static readFrom(view: BebopView): ISessionJoin {
    let field0: string;
    field0 = view.readString();
    let message: ISessionJoin = {
      id: field0,
    };
    return new SessionJoin(message);
  }
}


export interface ISessionLeave extends BebopRecord {
}

export class SessionLeave implements ISessionLeave {
  public readonly discriminator: number = 5 as 5;
  public static readonly discriminator: number = 5 as 5;

  constructor(record: ISessionLeave) {
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return SessionLeave.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ISessionLeave): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    SessionLeave.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link SessionLeave}.
   */
  public static validateCompatibility(record: ISessionLeave): void {

  }

  /**
   * Unsafely creates an instance of {@link SessionLeave} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ISessionLeave {
      return new SessionLeave(record);
  }

  /**
   * Creates a new {@link SessionLeave} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ISessionLeave {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`SessionLeave.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    SessionLeave.validateCompatibility(parsed);
    return SessionLeave.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return SessionLeave.encode(this);
  }

  public static encode(record: ISessionLeave): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    SessionLeave.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ISessionLeave, view: BebopView): number {
    const before = view.length;

    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ISessionLeave {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return SessionLeave.readFrom(view);
  }

  public static readFrom(view: BebopView): ISessionLeave {
    let message: ISessionLeave = {
    };
    return new SessionLeave(message);
  }
}


export interface ISessionGet extends BebopRecord {
}

export class SessionGet implements ISessionGet {
  public readonly discriminator: number = 6 as 6;
  public static readonly discriminator: number = 6 as 6;

  constructor(record: ISessionGet) {
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return SessionGet.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ISessionGet): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    SessionGet.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link SessionGet}.
   */
  public static validateCompatibility(record: ISessionGet): void {

  }

  /**
   * Unsafely creates an instance of {@link SessionGet} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ISessionGet {
      return new SessionGet(record);
  }

  /**
   * Creates a new {@link SessionGet} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ISessionGet {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`SessionGet.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    SessionGet.validateCompatibility(parsed);
    return SessionGet.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return SessionGet.encode(this);
  }

  public static encode(record: ISessionGet): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    SessionGet.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ISessionGet, view: BebopView): number {
    const before = view.length;

    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ISessionGet {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return SessionGet.readFrom(view);
  }

  public static readFrom(view: BebopView): ISessionGet {
    let message: ISessionGet = {
    };
    return new SessionGet(message);
  }
}


export interface ICurrentSongVerse extends BebopRecord {

  readonly songHash: string;

  readonly verseIdx: number;
}

export class CurrentSongVerse implements ICurrentSongVerse {
  public readonly discriminator: number = 7 as 7;
  public static readonly discriminator: number = 7 as 7;
  public readonly songHash: string;
  public readonly verseIdx: number;

  constructor(record: ICurrentSongVerse) {
    this.songHash = record.songHash;
    this.verseIdx = record.verseIdx;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return CurrentSongVerse.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ICurrentSongVerse): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    CurrentSongVerse.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link CurrentSongVerse}.
   */
  public static validateCompatibility(record: ICurrentSongVerse): void {
    BebopTypeGuard.ensureString(record.songHash)
    BebopTypeGuard.ensureUint8(record.verseIdx)
  }

  /**
   * Unsafely creates an instance of {@link CurrentSongVerse} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ICurrentSongVerse {
      return new CurrentSongVerse(record);
  }

  /**
   * Creates a new {@link CurrentSongVerse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ICurrentSongVerse {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`CurrentSongVerse.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    CurrentSongVerse.validateCompatibility(parsed);
    return CurrentSongVerse.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return CurrentSongVerse.encode(this);
  }

  public static encode(record: ICurrentSongVerse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    CurrentSongVerse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ICurrentSongVerse, view: BebopView): number {
    const before = view.length;
    view.writeString(record.songHash);
    view.writeByte(record.verseIdx);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ICurrentSongVerse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return CurrentSongVerse.readFrom(view);
  }

  public static readFrom(view: BebopView): ICurrentSongVerse {
    let field0: string;
    field0 = view.readString();
    let field1: number;
    field1 = view.readByte();
    let message: ICurrentSongVerse = {
      songHash: field0,
      verseIdx: field1,
    };
    return new CurrentSongVerse(message);
  }
}


export type ICommandType
  = { discriminator: 1, value: IHelloRequest }
  | { discriminator: 2, value: ISessionCreate }
  | { discriminator: 3, value: ISessionDelete }
  | { discriminator: 4, value: ISessionJoin }
  | { discriminator: 5, value: ISessionLeave }
  | { discriminator: 6, value: ISessionGet }
  | { discriminator: 7, value: ICurrentSongVerse };

export interface ICommand extends BebopRecord {
  readonly data: ICommandType;
}
export class Command implements ICommand {

  public readonly data: ICommandType;

  private constructor(data: ICommandType) {
    this.data = data;
  }

  public get discriminator() {
    return this.data.discriminator;
  }

  public get value() {
    return this.data.value;
  }

  public static fromHelloRequest(value: IHelloRequest) {
    return new Command({ discriminator: 1, value: new HelloRequest(value)});
  }

  public isHelloRequest(): this is { value: HelloRequest } & { data: Extract<ICommandType, { discriminator: 1 }> } {
    return this.data.value instanceof HelloRequest;
  }

  public static fromSessionCreate(value: ISessionCreate) {
    return new Command({ discriminator: 2, value: new SessionCreate(value)});
  }

  public isSessionCreate(): this is { value: SessionCreate } & { data: Extract<ICommandType, { discriminator: 2 }> } {
    return this.data.value instanceof SessionCreate;
  }

  public static fromSessionDelete(value: ISessionDelete) {
    return new Command({ discriminator: 3, value: new SessionDelete(value)});
  }

  public isSessionDelete(): this is { value: SessionDelete } & { data: Extract<ICommandType, { discriminator: 3 }> } {
    return this.data.value instanceof SessionDelete;
  }

  public static fromSessionJoin(value: ISessionJoin) {
    return new Command({ discriminator: 4, value: new SessionJoin(value)});
  }

  public isSessionJoin(): this is { value: SessionJoin } & { data: Extract<ICommandType, { discriminator: 4 }> } {
    return this.data.value instanceof SessionJoin;
  }

  public static fromSessionLeave(value: ISessionLeave) {
    return new Command({ discriminator: 5, value: new SessionLeave(value)});
  }

  public isSessionLeave(): this is { value: SessionLeave } & { data: Extract<ICommandType, { discriminator: 5 }> } {
    return this.data.value instanceof SessionLeave;
  }

  public static fromSessionGet(value: ISessionGet) {
    return new Command({ discriminator: 6, value: new SessionGet(value)});
  }

  public isSessionGet(): this is { value: SessionGet } & { data: Extract<ICommandType, { discriminator: 6 }> } {
    return this.data.value instanceof SessionGet;
  }

  public static fromCurrentSongVerse(value: ICurrentSongVerse) {
    return new Command({ discriminator: 7, value: new CurrentSongVerse(value)});
  }

  public isCurrentSongVerse(): this is { value: CurrentSongVerse } & { data: Extract<ICommandType, { discriminator: 7 }> } {
    return this.data.value instanceof CurrentSongVerse;
  }


  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return Command.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ICommand): string {
    delete (record.data.value as any).discriminator;
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Command.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Command}.
   */
  public static validateCompatibility(record: ICommand): void {
    const discriminator = record.data.discriminator;
    BebopTypeGuard.ensureUint8(discriminator);
    switch (discriminator) {
      case 1: {
        HelloRequest.validateCompatibility(record.data.value);
        break;
      }
      case 2: {
        SessionCreate.validateCompatibility(record.data.value);
        break;
      }
      case 3: {
        SessionDelete.validateCompatibility(record.data.value);
        break;
      }
      case 4: {
        SessionJoin.validateCompatibility(record.data.value);
        break;
      }
      case 5: {
        SessionLeave.validateCompatibility(record.data.value);
        break;
      }
      case 6: {
        SessionGet.validateCompatibility(record.data.value);
        break;
      }
      case 7: {
        CurrentSongVerse.validateCompatibility(record.data.value);
        break;
      }
      default: {
        throw new Error(`Unknown discriminator for Command: ${discriminator}`);
      }
    }
  }

  /**
   * Unsafely creates an instance of {@link Command} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): Command {
      const discriminator = record.data.discriminator;
      switch (discriminator) {
        case 1: {
          return new Command({ discriminator: 1, value: HelloRequest.unsafeCast(record.value) });
        }
        case 2: {
          return new Command({ discriminator: 2, value: SessionCreate.unsafeCast(record.value) });
        }
        case 3: {
          return new Command({ discriminator: 3, value: SessionDelete.unsafeCast(record.value) });
        }
        case 4: {
          return new Command({ discriminator: 4, value: SessionJoin.unsafeCast(record.value) });
        }
        case 5: {
          return new Command({ discriminator: 5, value: SessionLeave.unsafeCast(record.value) });
        }
        case 6: {
          return new Command({ discriminator: 6, value: SessionGet.unsafeCast(record.value) });
        }
        case 7: {
          return new Command({ discriminator: 7, value: CurrentSongVerse.unsafeCast(record.value) });
        }
      }
      throw new BebopRuntimeError(`Failed to unsafely cast union from discriminator: ${discriminator}`);
  }

  /**
   * Creates a new {@link Command} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): Command {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Command.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Command.validateCompatibility(parsed);
    return Command.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Command.encode(this);
  }

  public static encode(record: ICommand): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Command.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ICommand, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length + 1;
    view.writeByte(record.data.discriminator);
    switch (record.data.discriminator) {
      case 1:
        HelloRequest.encodeInto(record.data.value, view);
        break;
      case 2:
        SessionCreate.encodeInto(record.data.value, view);
        break;
      case 3:
        SessionDelete.encodeInto(record.data.value, view);
        break;
      case 4:
        SessionJoin.encodeInto(record.data.value, view);
        break;
      case 5:
        SessionLeave.encodeInto(record.data.value, view);
        break;
      case 6:
        SessionGet.encodeInto(record.data.value, view);
        break;
      case 7:
        CurrentSongVerse.encodeInto(record.data.value, view);
        break;
    }
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): Command {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Command.readFrom(view);
  }

  public static readFrom(view: BebopView): Command {
    const length = view.readMessageLength();
    const end = view.index + 1 + length;
    switch (view.readByte()) {
      case 1:
        return this.fromHelloRequest(HelloRequest.readFrom(view));
      case 2:
        return this.fromSessionCreate(SessionCreate.readFrom(view));
      case 3:
        return this.fromSessionDelete(SessionDelete.readFrom(view));
      case 4:
        return this.fromSessionJoin(SessionJoin.readFrom(view));
      case 5:
        return this.fromSessionLeave(SessionLeave.readFrom(view));
      case 6:
        return this.fromSessionGet(SessionGet.readFrom(view));
      case 7:
        return this.fromCurrentSongVerse(CurrentSongVerse.readFrom(view));
      default:
        view.index = end;
        throw new BebopRuntimeError("Unrecognized discriminator while decoding Command");
    }
  }
}


export interface IInfoMessage extends BebopRecord {

  readonly text: string;
}

export class InfoMessage implements IInfoMessage {
  public readonly discriminator: number = 1 as 1;
  public static readonly discriminator: number = 1 as 1;
  public readonly text: string;

  constructor(record: IInfoMessage) {
    this.text = record.text;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return InfoMessage.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IInfoMessage): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    InfoMessage.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link InfoMessage}.
   */
  public static validateCompatibility(record: IInfoMessage): void {
    BebopTypeGuard.ensureString(record.text)
  }

  /**
   * Unsafely creates an instance of {@link InfoMessage} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IInfoMessage {
      return new InfoMessage(record);
  }

  /**
   * Creates a new {@link InfoMessage} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IInfoMessage {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`InfoMessage.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    InfoMessage.validateCompatibility(parsed);
    return InfoMessage.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return InfoMessage.encode(this);
  }

  public static encode(record: IInfoMessage): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    InfoMessage.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IInfoMessage, view: BebopView): number {
    const before = view.length;
    view.writeString(record.text);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IInfoMessage {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return InfoMessage.readFrom(view);
  }

  public static readFrom(view: BebopView): IInfoMessage {
    let field0: string;
    field0 = view.readString();
    let message: IInfoMessage = {
      text: field0,
    };
    return new InfoMessage(message);
  }
}


export interface IErrorMessage extends BebopRecord {

  readonly code: number;

  readonly text: string;
}

export class ErrorMessage implements IErrorMessage {
  public readonly discriminator: number = 2 as 2;
  public static readonly discriminator: number = 2 as 2;
  public readonly code: number;
  public readonly text: string;

  constructor(record: IErrorMessage) {
    this.code = record.code;
    this.text = record.text;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return ErrorMessage.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IErrorMessage): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    ErrorMessage.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link ErrorMessage}.
   */
  public static validateCompatibility(record: IErrorMessage): void {
    BebopTypeGuard.ensureUint8(record.code)
    BebopTypeGuard.ensureString(record.text)
  }

  /**
   * Unsafely creates an instance of {@link ErrorMessage} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IErrorMessage {
      return new ErrorMessage(record);
  }

  /**
   * Creates a new {@link ErrorMessage} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IErrorMessage {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`ErrorMessage.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    ErrorMessage.validateCompatibility(parsed);
    return ErrorMessage.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return ErrorMessage.encode(this);
  }

  public static encode(record: IErrorMessage): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    ErrorMessage.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IErrorMessage, view: BebopView): number {
    const before = view.length;
    view.writeByte(record.code);
    view.writeString(record.text);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IErrorMessage {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return ErrorMessage.readFrom(view);
  }

  public static readFrom(view: BebopView): IErrorMessage {
    let field0: number;
    field0 = view.readByte();
    let field1: string;
    field1 = view.readString();
    let message: IErrorMessage = {
      code: field0,
      text: field1,
    };
    return new ErrorMessage(message);
  }
}


export interface IHelloResponse extends BebopRecord {

  readonly uid: string;
}

export class HelloResponse implements IHelloResponse {
  public readonly discriminator: number = 3 as 3;
  public static readonly discriminator: number = 3 as 3;
  public readonly uid: string;

  constructor(record: IHelloResponse) {
    this.uid = record.uid;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return HelloResponse.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IHelloResponse): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    HelloResponse.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link HelloResponse}.
   */
  public static validateCompatibility(record: IHelloResponse): void {
    BebopTypeGuard.ensureString(record.uid)
  }

  /**
   * Unsafely creates an instance of {@link HelloResponse} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IHelloResponse {
      return new HelloResponse(record);
  }

  /**
   * Creates a new {@link HelloResponse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IHelloResponse {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`HelloResponse.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    HelloResponse.validateCompatibility(parsed);
    return HelloResponse.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return HelloResponse.encode(this);
  }

  public static encode(record: IHelloResponse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    HelloResponse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IHelloResponse, view: BebopView): number {
    const before = view.length;
    view.writeString(record.uid);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IHelloResponse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return HelloResponse.readFrom(view);
  }

  public static readFrom(view: BebopView): IHelloResponse {
    let field0: string;
    field0 = view.readString();
    let message: IHelloResponse = {
      uid: field0,
    };
    return new HelloResponse(message);
  }
}


export interface ISessionDetails extends BebopRecord {

  readonly id: string;

  readonly expires: Date;

  readonly members: Array<ISessionMember>;
}

export class SessionDetails implements ISessionDetails {
  public readonly discriminator: number = 4 as 4;
  public static readonly discriminator: number = 4 as 4;
  public readonly id: string;
  public readonly expires: Date;
  public readonly members: Array<ISessionMember>;

  constructor(record: ISessionDetails) {
    this.id = record.id;
    this.expires = record.expires;
    this.members = record.members;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return SessionDetails.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ISessionDetails): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    SessionDetails.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link SessionDetails}.
   */
  public static validateCompatibility(record: ISessionDetails): void {
    BebopTypeGuard.ensureString(record.id)
    BebopTypeGuard.ensureDate(record.expires)
    BebopTypeGuard.ensureArray(record.members, SessionMember.validateCompatibility);
  }

  /**
   * Unsafely creates an instance of {@link SessionDetails} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ISessionDetails {
      return new SessionDetails(record);
  }

  /**
   * Creates a new {@link SessionDetails} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ISessionDetails {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`SessionDetails.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    SessionDetails.validateCompatibility(parsed);
    return SessionDetails.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return SessionDetails.encode(this);
  }

  public static encode(record: ISessionDetails): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    SessionDetails.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ISessionDetails, view: BebopView): number {
    const before = view.length;
    view.writeString(record.id);
    view.writeDate(record.expires);
    {
      const length0 = record.members.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        SessionMember.encodeInto(record.members[i0], view)
      }
    }
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ISessionDetails {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return SessionDetails.readFrom(view);
  }

  public static readFrom(view: BebopView): ISessionDetails {
    let field0: string;
    field0 = view.readString();
    let field1: Date;
    field1 = view.readDate();
    let field2: Array<ISessionMember>;
    {
      let length0 = view.readUint32();
      field2 = new Array<ISessionMember>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: ISessionMember;
        x0 = SessionMember.readFrom(view);
        field2[i0] = x0;
      }
    }
    let message: ISessionDetails = {
      id: field0,
      expires: field1,
      members: field2,
    };
    return new SessionDetails(message);
  }
}


export interface IMarkSongVerse extends BebopRecord {

  readonly songHash: string;

  readonly verseIdx: number;
}

export class MarkSongVerse implements IMarkSongVerse {
  public readonly discriminator: number = 5 as 5;
  public static readonly discriminator: number = 5 as 5;
  public readonly songHash: string;
  public readonly verseIdx: number;

  constructor(record: IMarkSongVerse) {
    this.songHash = record.songHash;
    this.verseIdx = record.verseIdx;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return MarkSongVerse.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IMarkSongVerse): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    MarkSongVerse.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link MarkSongVerse}.
   */
  public static validateCompatibility(record: IMarkSongVerse): void {
    BebopTypeGuard.ensureString(record.songHash)
    BebopTypeGuard.ensureUint8(record.verseIdx)
  }

  /**
   * Unsafely creates an instance of {@link MarkSongVerse} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IMarkSongVerse {
      return new MarkSongVerse(record);
  }

  /**
   * Creates a new {@link MarkSongVerse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IMarkSongVerse {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`MarkSongVerse.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    MarkSongVerse.validateCompatibility(parsed);
    return MarkSongVerse.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return MarkSongVerse.encode(this);
  }

  public static encode(record: IMarkSongVerse): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    MarkSongVerse.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IMarkSongVerse, view: BebopView): number {
    const before = view.length;
    view.writeString(record.songHash);
    view.writeByte(record.verseIdx);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IMarkSongVerse {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return MarkSongVerse.readFrom(view);
  }

  public static readFrom(view: BebopView): IMarkSongVerse {
    let field0: string;
    field0 = view.readString();
    let field1: number;
    field1 = view.readByte();
    let message: IMarkSongVerse = {
      songHash: field0,
      verseIdx: field1,
    };
    return new MarkSongVerse(message);
  }
}


export type IMessageType
  = { discriminator: 1, value: IInfoMessage }
  | { discriminator: 2, value: IErrorMessage }
  | { discriminator: 3, value: IHelloResponse }
  | { discriminator: 4, value: ISessionDetails }
  | { discriminator: 5, value: IMarkSongVerse };

export interface IMessage extends BebopRecord {
  readonly data: IMessageType;
}
export class Message implements IMessage {

  public readonly data: IMessageType;

  private constructor(data: IMessageType) {
    this.data = data;
  }

  public get discriminator() {
    return this.data.discriminator;
  }

  public get value() {
    return this.data.value;
  }

  public static fromInfoMessage(value: IInfoMessage) {
    return new Message({ discriminator: 1, value: new InfoMessage(value)});
  }

  public isInfoMessage(): this is { value: InfoMessage } & { data: Extract<IMessageType, { discriminator: 1 }> } {
    return this.data.value instanceof InfoMessage;
  }

  public static fromErrorMessage(value: IErrorMessage) {
    return new Message({ discriminator: 2, value: new ErrorMessage(value)});
  }

  public isErrorMessage(): this is { value: ErrorMessage } & { data: Extract<IMessageType, { discriminator: 2 }> } {
    return this.data.value instanceof ErrorMessage;
  }

  public static fromHelloResponse(value: IHelloResponse) {
    return new Message({ discriminator: 3, value: new HelloResponse(value)});
  }

  public isHelloResponse(): this is { value: HelloResponse } & { data: Extract<IMessageType, { discriminator: 3 }> } {
    return this.data.value instanceof HelloResponse;
  }

  public static fromSessionDetails(value: ISessionDetails) {
    return new Message({ discriminator: 4, value: new SessionDetails(value)});
  }

  public isSessionDetails(): this is { value: SessionDetails } & { data: Extract<IMessageType, { discriminator: 4 }> } {
    return this.data.value instanceof SessionDetails;
  }

  public static fromMarkSongVerse(value: IMarkSongVerse) {
    return new Message({ discriminator: 5, value: new MarkSongVerse(value)});
  }

  public isMarkSongVerse(): this is { value: MarkSongVerse } & { data: Extract<IMessageType, { discriminator: 5 }> } {
    return this.data.value instanceof MarkSongVerse;
  }


  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public stringify(): string {
    return Message.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IMessage): string {
    delete (record.data.value as any).discriminator;
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Message.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Message}.
   */
  public static validateCompatibility(record: IMessage): void {
    const discriminator = record.data.discriminator;
    BebopTypeGuard.ensureUint8(discriminator);
    switch (discriminator) {
      case 1: {
        InfoMessage.validateCompatibility(record.data.value);
        break;
      }
      case 2: {
        ErrorMessage.validateCompatibility(record.data.value);
        break;
      }
      case 3: {
        HelloResponse.validateCompatibility(record.data.value);
        break;
      }
      case 4: {
        SessionDetails.validateCompatibility(record.data.value);
        break;
      }
      case 5: {
        MarkSongVerse.validateCompatibility(record.data.value);
        break;
      }
      default: {
        throw new Error(`Unknown discriminator for Message: ${discriminator}`);
      }
    }
  }

  /**
   * Unsafely creates an instance of {@link Message} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): Message {
      const discriminator = record.data.discriminator;
      switch (discriminator) {
        case 1: {
          return new Message({ discriminator: 1, value: InfoMessage.unsafeCast(record.value) });
        }
        case 2: {
          return new Message({ discriminator: 2, value: ErrorMessage.unsafeCast(record.value) });
        }
        case 3: {
          return new Message({ discriminator: 3, value: HelloResponse.unsafeCast(record.value) });
        }
        case 4: {
          return new Message({ discriminator: 4, value: SessionDetails.unsafeCast(record.value) });
        }
        case 5: {
          return new Message({ discriminator: 5, value: MarkSongVerse.unsafeCast(record.value) });
        }
      }
      throw new BebopRuntimeError(`Failed to unsafely cast union from discriminator: ${discriminator}`);
  }

  /**
   * Creates a new {@link Message} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): Message {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Message.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Message.validateCompatibility(parsed);
    return Message.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Message.encode(this);
  }

  public static encode(record: IMessage): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Message.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IMessage, view: BebopView): number {
    const before = view.length;
    const pos = view.reserveMessageLength();
    const start = view.length + 1;
    view.writeByte(record.data.discriminator);
    switch (record.data.discriminator) {
      case 1:
        InfoMessage.encodeInto(record.data.value, view);
        break;
      case 2:
        ErrorMessage.encodeInto(record.data.value, view);
        break;
      case 3:
        HelloResponse.encodeInto(record.data.value, view);
        break;
      case 4:
        SessionDetails.encodeInto(record.data.value, view);
        break;
      case 5:
        MarkSongVerse.encodeInto(record.data.value, view);
        break;
    }
    const end = view.length;
    view.fillMessageLength(pos, end - start);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): Message {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Message.readFrom(view);
  }

  public static readFrom(view: BebopView): Message {
    const length = view.readMessageLength();
    const end = view.index + 1 + length;
    switch (view.readByte()) {
      case 1:
        return this.fromInfoMessage(InfoMessage.readFrom(view));
      case 2:
        return this.fromErrorMessage(ErrorMessage.readFrom(view));
      case 3:
        return this.fromHelloResponse(HelloResponse.readFrom(view));
      case 4:
        return this.fromSessionDetails(SessionDetails.readFrom(view));
      case 5:
        return this.fromMarkSongVerse(MarkSongVerse.readFrom(view));
      default:
        view.index = end;
        throw new BebopRuntimeError("Unrecognized discriminator while decoding Message");
    }
  }
}

