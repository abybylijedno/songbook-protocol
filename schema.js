//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.1.3
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
import { BebopView, BebopRuntimeError, BebopJson, BebopTypeGuard } from "bebop";
export var BEBOP_SCHEMA = new Uint8Array([
    3,
    17,
    0,
    0,
    0,
    85,
    115,
    101,
    114,
    0,
    2,
    0,
    5,
    0,
    0,
    0,
    2,
    110,
    97,
    109,
    101,
    0,
    245,
    255,
    255,
    255,
    0,
    1,
    117,
    105,
    100,
    0,
    245,
    255,
    255,
    255,
    0,
    2,
    83,
    101,
    115,
    115,
    105,
    111,
    110,
    77,
    101,
    109,
    98,
    101,
    114,
    82,
    111,
    108,
    101,
    0,
    4,
    0,
    251,
    255,
    255,
    255,
    0,
    4,
    0,
    0,
    0,
    2,
    67,
    82,
    69,
    65,
    84,
    79,
    82,
    0,
    0,
    1,
    0,
    0,
    0,
    77,
    69,
    77,
    66,
    69,
    82,
    0,
    0,
    2,
    0,
    0,
    0,
    83,
    101,
    115,
    115,
    105,
    111,
    110,
    77,
    101,
    109,
    98,
    101,
    114,
    0,
    1,
    0,
    0,
    9,
    0,
    0,
    0,
    0,
    2,
    117,
    115,
    101,
    114,
    0,
    0,
    0,
    0,
    0,
    0,
    114,
    111,
    108,
    101,
    0,
    1,
    0,
    0,
    0,
    0,
    72,
    101,
    108,
    108,
    111,
    82,
    101,
    113,
    117,
    101,
    115,
    116,
    0,
    2,
    0,
    5,
    0,
    0,
    0,
    2,
    110,
    97,
    109,
    101,
    0,
    245,
    255,
    255,
    255,
    0,
    1,
    117,
    105,
    100,
    0,
    245,
    255,
    255,
    255,
    0,
    2,
    83,
    101,
    115,
    115,
    105,
    111,
    110,
    67,
    114,
    101,
    97,
    116,
    101,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    83,
    101,
    115,
    115,
    105,
    111,
    110,
    68,
    101,
    108,
    101,
    116,
    101,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    83,
    101,
    115,
    115,
    105,
    111,
    110,
    74,
    111,
    105,
    110,
    0,
    1,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    1,
    105,
    100,
    0,
    245,
    255,
    255,
    255,
    0,
    83,
    101,
    115,
    115,
    105,
    111,
    110,
    76,
    101,
    97,
    118,
    101,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    83,
    101,
    115,
    115,
    105,
    111,
    110,
    71,
    101,
    116,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    83,
    112,
    114,
    101,
    97,
    100,
    83,
    111,
    110,
    103,
    86,
    101,
    114,
    115,
    101,
    0,
    1,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    2,
    115,
    111,
    110,
    103,
    72,
    97,
    115,
    104,
    0,
    245,
    255,
    255,
    255,
    0,
    118,
    101,
    114,
    115,
    101,
    73,
    100,
    120,
    0,
    254,
    255,
    255,
    255,
    0,
    67,
    111,
    109,
    109,
    97,
    110,
    100,
    0,
    3,
    0,
    5,
    0,
    0,
    0,
    7,
    1,
    3,
    0,
    0,
    0,
    2,
    4,
    0,
    0,
    0,
    3,
    5,
    0,
    0,
    0,
    4,
    6,
    0,
    0,
    0,
    5,
    7,
    0,
    0,
    0,
    6,
    8,
    0,
    0,
    0,
    7,
    9,
    0,
    0,
    0,
    73,
    110,
    102,
    111,
    77,
    101,
    115,
    115,
    97,
    103,
    101,
    0,
    1,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    1,
    116,
    101,
    120,
    116,
    0,
    245,
    255,
    255,
    255,
    0,
    69,
    114,
    114,
    111,
    114,
    77,
    101,
    115,
    115,
    97,
    103,
    101,
    0,
    1,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    2,
    99,
    111,
    100,
    101,
    0,
    254,
    255,
    255,
    255,
    0,
    116,
    101,
    120,
    116,
    0,
    245,
    255,
    255,
    255,
    0,
    72,
    101,
    108,
    108,
    111,
    82,
    101,
    115,
    112,
    111,
    110,
    115,
    101,
    0,
    1,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    1,
    117,
    105,
    100,
    0,
    245,
    255,
    255,
    255,
    0,
    83,
    101,
    115,
    115,
    105,
    111,
    110,
    68,
    101,
    116,
    97,
    105,
    108,
    115,
    0,
    1,
    0,
    0,
    16,
    0,
    0,
    0,
    0,
    3,
    105,
    100,
    0,
    245,
    255,
    255,
    255,
    0,
    101,
    120,
    112,
    105,
    114,
    101,
    115,
    0,
    243,
    255,
    255,
    255,
    0,
    109,
    101,
    109,
    98,
    101,
    114,
    115,
    0,
    242,
    255,
    255,
    255,
    0,
    2,
    0,
    0,
    0,
    0,
    67,
    117,
    114,
    114,
    101,
    110,
    116,
    83,
    111,
    110,
    103,
    86,
    101,
    114,
    115,
    101,
    0,
    1,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    2,
    115,
    111,
    110,
    103,
    72,
    97,
    115,
    104,
    0,
    245,
    255,
    255,
    255,
    0,
    118,
    101,
    114,
    115,
    101,
    73,
    100,
    120,
    0,
    254,
    255,
    255,
    255,
    0,
    77,
    101,
    115,
    115,
    97,
    103,
    101,
    0,
    3,
    0,
    9,
    0,
    0,
    0,
    5,
    1,
    11,
    0,
    0,
    0,
    2,
    12,
    0,
    0,
    0,
    3,
    13,
    0,
    0,
    0,
    4,
    14,
    0,
    0,
    0,
    5,
    15,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
export var User = /*#__PURE__*/ function() {
    "use strict";
    function User(record) {
        _class_call_check(this, User);
        _define_property(this, "name", void 0);
        _define_property(this, "uid", void 0);
        this.name = record.name;
        this.uid = record.uid;
    }
    _create_class(User, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return User.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                User.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return User.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link User}.
   */ function validateCompatibility(record) {
                if (record.name !== undefined) {
                    BebopTypeGuard.ensureString(record.name);
                }
                if (record.uid !== undefined) {
                    BebopTypeGuard.ensureString(record.uid);
                }
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link User} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new User(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link User} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("User.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                User.validateCompatibility(parsed);
                return User.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                User.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var pos = view.reserveMessageLength();
                var start = view.length;
                if (record.name !== undefined) {
                    view.writeByte(1);
                    view.writeString(record.name);
                }
                if (record.uid !== undefined) {
                    view.writeByte(2);
                    view.writeString(record.uid);
                }
                view.writeByte(0);
                var end = view.length;
                view.fillMessageLength(pos, end - start);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return User.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                var length = view.readMessageLength();
                var end = view.index + length;
                while(true){
                    switch(view.readByte()){
                        case 0:
                            return new User(message);
                        case 1:
                            message.name = view.readString();
                            break;
                        case 2:
                            message.uid = view.readString();
                            break;
                        default:
                            view.index = end;
                            return new User(message);
                    }
                }
            }
        }
    ]);
    return User;
}();
export var SessionMemberRole = /*#__PURE__*/ function(SessionMemberRole) {
    SessionMemberRole[SessionMemberRole["Creator"] = 1] = "Creator";
    SessionMemberRole[SessionMemberRole["Member"] = 2] = "Member";
    return SessionMemberRole;
}({});
export var SessionMember = /*#__PURE__*/ function() {
    "use strict";
    function SessionMember(record) {
        _class_call_check(this, SessionMember);
        _define_property(this, "user", void 0);
        _define_property(this, "role", void 0);
        this.user = record.user;
        this.role = record.role;
    }
    _create_class(SessionMember, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return SessionMember.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                SessionMember.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return SessionMember.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link SessionMember}.
   */ function validateCompatibility(record) {
                User.validateCompatibility(record.user);
                BebopTypeGuard.ensureEnum(record.role, SessionMemberRole);
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link SessionMember} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                record.user = User.unsafeCast(record.user);
                return new SessionMember(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link SessionMember} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("SessionMember.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                SessionMember.validateCompatibility(parsed);
                return SessionMember.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                SessionMember.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                User.encodeInto(record.user, view);
                view.writeUint32(record.role);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return SessionMember.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var field0;
                field0 = User.readFrom(view);
                var field1;
                field1 = view.readUint32();
                var message = {
                    user: field0,
                    role: field1
                };
                return new SessionMember(message);
            }
        }
    ]);
    return SessionMember;
}();
export var HelloRequest = /*#__PURE__*/ function() {
    "use strict";
    function HelloRequest(record) {
        _class_call_check(this, HelloRequest);
        _define_property(this, "discriminator", 1);
        _define_property(this, "name", void 0);
        _define_property(this, "uid", void 0);
        this.name = record.name;
        this.uid = record.uid;
    }
    _create_class(HelloRequest, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return HelloRequest.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                HelloRequest.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return HelloRequest.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link HelloRequest}.
   */ function validateCompatibility(record) {
                if (record.name !== undefined) {
                    BebopTypeGuard.ensureString(record.name);
                }
                if (record.uid !== undefined) {
                    BebopTypeGuard.ensureString(record.uid);
                }
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link HelloRequest} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new HelloRequest(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link HelloRequest} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("HelloRequest.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                HelloRequest.validateCompatibility(parsed);
                return HelloRequest.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                HelloRequest.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var pos = view.reserveMessageLength();
                var start = view.length;
                if (record.name !== undefined) {
                    view.writeByte(1);
                    view.writeString(record.name);
                }
                if (record.uid !== undefined) {
                    view.writeByte(2);
                    view.writeString(record.uid);
                }
                view.writeByte(0);
                var end = view.length;
                view.fillMessageLength(pos, end - start);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return HelloRequest.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                var length = view.readMessageLength();
                var end = view.index + length;
                while(true){
                    switch(view.readByte()){
                        case 0:
                            return new HelloRequest(message);
                        case 1:
                            message.name = view.readString();
                            break;
                        case 2:
                            message.uid = view.readString();
                            break;
                        default:
                            view.index = end;
                            return new HelloRequest(message);
                    }
                }
            }
        }
    ]);
    return HelloRequest;
}();
_define_property(HelloRequest, "discriminator", 1);
export var SessionCreate = /*#__PURE__*/ function() {
    "use strict";
    function SessionCreate(record) {
        _class_call_check(this, SessionCreate);
        _define_property(this, "discriminator", 2);
    }
    _create_class(SessionCreate, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return SessionCreate.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                SessionCreate.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return SessionCreate.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link SessionCreate}.
   */ function validateCompatibility(record) {}
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link SessionCreate} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new SessionCreate(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link SessionCreate} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("SessionCreate.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                SessionCreate.validateCompatibility(parsed);
                return SessionCreate.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                SessionCreate.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return SessionCreate.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                return new SessionCreate(message);
            }
        }
    ]);
    return SessionCreate;
}();
_define_property(SessionCreate, "discriminator", 2);
export var SessionDelete = /*#__PURE__*/ function() {
    "use strict";
    function SessionDelete(record) {
        _class_call_check(this, SessionDelete);
        _define_property(this, "discriminator", 3);
    }
    _create_class(SessionDelete, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return SessionDelete.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                SessionDelete.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return SessionDelete.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link SessionDelete}.
   */ function validateCompatibility(record) {}
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link SessionDelete} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new SessionDelete(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link SessionDelete} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("SessionDelete.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                SessionDelete.validateCompatibility(parsed);
                return SessionDelete.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                SessionDelete.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return SessionDelete.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                return new SessionDelete(message);
            }
        }
    ]);
    return SessionDelete;
}();
_define_property(SessionDelete, "discriminator", 3);
export var SessionJoin = /*#__PURE__*/ function() {
    "use strict";
    function SessionJoin(record) {
        _class_call_check(this, SessionJoin);
        _define_property(this, "discriminator", 4);
        _define_property(this, "id", void 0);
        this.id = record.id;
    }
    _create_class(SessionJoin, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return SessionJoin.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                SessionJoin.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return SessionJoin.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link SessionJoin}.
   */ function validateCompatibility(record) {
                BebopTypeGuard.ensureString(record.id);
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link SessionJoin} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new SessionJoin(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link SessionJoin} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("SessionJoin.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                SessionJoin.validateCompatibility(parsed);
                return SessionJoin.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                SessionJoin.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                view.writeString(record.id);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return SessionJoin.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var field0;
                field0 = view.readString();
                var message = {
                    id: field0
                };
                return new SessionJoin(message);
            }
        }
    ]);
    return SessionJoin;
}();
_define_property(SessionJoin, "discriminator", 4);
export var SessionLeave = /*#__PURE__*/ function() {
    "use strict";
    function SessionLeave(record) {
        _class_call_check(this, SessionLeave);
        _define_property(this, "discriminator", 5);
    }
    _create_class(SessionLeave, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return SessionLeave.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                SessionLeave.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return SessionLeave.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link SessionLeave}.
   */ function validateCompatibility(record) {}
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link SessionLeave} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new SessionLeave(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link SessionLeave} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("SessionLeave.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                SessionLeave.validateCompatibility(parsed);
                return SessionLeave.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                SessionLeave.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return SessionLeave.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                return new SessionLeave(message);
            }
        }
    ]);
    return SessionLeave;
}();
_define_property(SessionLeave, "discriminator", 5);
export var SessionGet = /*#__PURE__*/ function() {
    "use strict";
    function SessionGet(record) {
        _class_call_check(this, SessionGet);
        _define_property(this, "discriminator", 6);
    }
    _create_class(SessionGet, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return SessionGet.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                SessionGet.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return SessionGet.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link SessionGet}.
   */ function validateCompatibility(record) {}
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link SessionGet} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new SessionGet(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link SessionGet} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("SessionGet.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                SessionGet.validateCompatibility(parsed);
                return SessionGet.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                SessionGet.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return SessionGet.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var message = {};
                return new SessionGet(message);
            }
        }
    ]);
    return SessionGet;
}();
_define_property(SessionGet, "discriminator", 6);
export var SpreadSongVerse = /*#__PURE__*/ function() {
    "use strict";
    function SpreadSongVerse(record) {
        _class_call_check(this, SpreadSongVerse);
        _define_property(this, "discriminator", 7);
        _define_property(this, "songHash", void 0);
        _define_property(this, "verseIdx", void 0);
        this.songHash = record.songHash;
        this.verseIdx = record.verseIdx;
    }
    _create_class(SpreadSongVerse, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return SpreadSongVerse.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                SpreadSongVerse.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return SpreadSongVerse.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link SpreadSongVerse}.
   */ function validateCompatibility(record) {
                BebopTypeGuard.ensureString(record.songHash);
                BebopTypeGuard.ensureUint8(record.verseIdx);
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link SpreadSongVerse} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new SpreadSongVerse(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link SpreadSongVerse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("SpreadSongVerse.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                SpreadSongVerse.validateCompatibility(parsed);
                return SpreadSongVerse.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                SpreadSongVerse.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                view.writeString(record.songHash);
                view.writeByte(record.verseIdx);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return SpreadSongVerse.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var field0;
                field0 = view.readString();
                var field1;
                field1 = view.readByte();
                var message = {
                    songHash: field0,
                    verseIdx: field1
                };
                return new SpreadSongVerse(message);
            }
        }
    ]);
    return SpreadSongVerse;
}();
_define_property(SpreadSongVerse, "discriminator", 7);
export var Command = /*#__PURE__*/ function() {
    "use strict";
    function Command(data) {
        _class_call_check(this, Command);
        _define_property(this, "data", void 0);
        this.data = data;
    }
    _create_class(Command, [
        {
            key: "discriminator",
            get: function get() {
                return this.data.discriminator;
            }
        },
        {
            key: "value",
            get: function get() {
                return this.data.value;
            }
        },
        {
            key: "isHelloRequest",
            value: function isHelloRequest() {
                return _instanceof(this.data.value, HelloRequest);
            }
        },
        {
            key: "isSessionCreate",
            value: function isSessionCreate() {
                return _instanceof(this.data.value, SessionCreate);
            }
        },
        {
            key: "isSessionDelete",
            value: function isSessionDelete() {
                return _instanceof(this.data.value, SessionDelete);
            }
        },
        {
            key: "isSessionJoin",
            value: function isSessionJoin() {
                return _instanceof(this.data.value, SessionJoin);
            }
        },
        {
            key: "isSessionLeave",
            value: function isSessionLeave() {
                return _instanceof(this.data.value, SessionLeave);
            }
        },
        {
            key: "isSessionGet",
            value: function isSessionGet() {
                return _instanceof(this.data.value, SessionGet);
            }
        },
        {
            key: "isSpreadSongVerse",
            value: function isSpreadSongVerse() {
                return _instanceof(this.data.value, SpreadSongVerse);
            }
        },
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return Command.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                Command.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return Command.encode(this);
            }
        }
    ], [
        {
            key: "fromHelloRequest",
            value: function fromHelloRequest(value) {
                return new Command({
                    discriminator: 1,
                    value: new HelloRequest(value)
                });
            }
        },
        {
            key: "fromSessionCreate",
            value: function fromSessionCreate(value) {
                return new Command({
                    discriminator: 2,
                    value: new SessionCreate(value)
                });
            }
        },
        {
            key: "fromSessionDelete",
            value: function fromSessionDelete(value) {
                return new Command({
                    discriminator: 3,
                    value: new SessionDelete(value)
                });
            }
        },
        {
            key: "fromSessionJoin",
            value: function fromSessionJoin(value) {
                return new Command({
                    discriminator: 4,
                    value: new SessionJoin(value)
                });
            }
        },
        {
            key: "fromSessionLeave",
            value: function fromSessionLeave(value) {
                return new Command({
                    discriminator: 5,
                    value: new SessionLeave(value)
                });
            }
        },
        {
            key: "fromSessionGet",
            value: function fromSessionGet(value) {
                return new Command({
                    discriminator: 6,
                    value: new SessionGet(value)
                });
            }
        },
        {
            key: "fromSpreadSongVerse",
            value: function fromSpreadSongVerse(value) {
                return new Command({
                    discriminator: 7,
                    value: new SpreadSongVerse(value)
                });
            }
        },
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                delete record.data.value.discriminator;
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link Command}.
   */ function validateCompatibility(record) {
                var discriminator = record.data.discriminator;
                BebopTypeGuard.ensureUint8(discriminator);
                switch(discriminator){
                    case 1:
                        {
                            HelloRequest.validateCompatibility(record.data.value);
                            break;
                        }
                    case 2:
                        {
                            SessionCreate.validateCompatibility(record.data.value);
                            break;
                        }
                    case 3:
                        {
                            SessionDelete.validateCompatibility(record.data.value);
                            break;
                        }
                    case 4:
                        {
                            SessionJoin.validateCompatibility(record.data.value);
                            break;
                        }
                    case 5:
                        {
                            SessionLeave.validateCompatibility(record.data.value);
                            break;
                        }
                    case 6:
                        {
                            SessionGet.validateCompatibility(record.data.value);
                            break;
                        }
                    case 7:
                        {
                            SpreadSongVerse.validateCompatibility(record.data.value);
                            break;
                        }
                    default:
                        {
                            throw new Error("Unknown discriminator for Command: ".concat(discriminator));
                        }
                }
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link Command} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                var discriminator = record.data.discriminator;
                switch(discriminator){
                    case 1:
                        {
                            return new Command({
                                discriminator: 1,
                                value: HelloRequest.unsafeCast(record.value)
                            });
                        }
                    case 2:
                        {
                            return new Command({
                                discriminator: 2,
                                value: SessionCreate.unsafeCast(record.value)
                            });
                        }
                    case 3:
                        {
                            return new Command({
                                discriminator: 3,
                                value: SessionDelete.unsafeCast(record.value)
                            });
                        }
                    case 4:
                        {
                            return new Command({
                                discriminator: 4,
                                value: SessionJoin.unsafeCast(record.value)
                            });
                        }
                    case 5:
                        {
                            return new Command({
                                discriminator: 5,
                                value: SessionLeave.unsafeCast(record.value)
                            });
                        }
                    case 6:
                        {
                            return new Command({
                                discriminator: 6,
                                value: SessionGet.unsafeCast(record.value)
                            });
                        }
                    case 7:
                        {
                            return new Command({
                                discriminator: 7,
                                value: SpreadSongVerse.unsafeCast(record.value)
                            });
                        }
                }
                throw new BebopRuntimeError("Failed to unsafely cast union from discriminator: ".concat(discriminator));
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link Command} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("Command.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                Command.validateCompatibility(parsed);
                return Command.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                Command.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var pos = view.reserveMessageLength();
                var start = view.length + 1;
                view.writeByte(record.data.discriminator);
                switch(record.data.discriminator){
                    case 1:
                        HelloRequest.encodeInto(record.data.value, view);
                        break;
                    case 2:
                        SessionCreate.encodeInto(record.data.value, view);
                        break;
                    case 3:
                        SessionDelete.encodeInto(record.data.value, view);
                        break;
                    case 4:
                        SessionJoin.encodeInto(record.data.value, view);
                        break;
                    case 5:
                        SessionLeave.encodeInto(record.data.value, view);
                        break;
                    case 6:
                        SessionGet.encodeInto(record.data.value, view);
                        break;
                    case 7:
                        SpreadSongVerse.encodeInto(record.data.value, view);
                        break;
                }
                var end = view.length;
                view.fillMessageLength(pos, end - start);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return Command.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var length = view.readMessageLength();
                var end = view.index + 1 + length;
                switch(view.readByte()){
                    case 1:
                        return this.fromHelloRequest(HelloRequest.readFrom(view));
                    case 2:
                        return this.fromSessionCreate(SessionCreate.readFrom(view));
                    case 3:
                        return this.fromSessionDelete(SessionDelete.readFrom(view));
                    case 4:
                        return this.fromSessionJoin(SessionJoin.readFrom(view));
                    case 5:
                        return this.fromSessionLeave(SessionLeave.readFrom(view));
                    case 6:
                        return this.fromSessionGet(SessionGet.readFrom(view));
                    case 7:
                        return this.fromSpreadSongVerse(SpreadSongVerse.readFrom(view));
                    default:
                        view.index = end;
                        throw new BebopRuntimeError("Unrecognized discriminator while decoding Command");
                }
            }
        }
    ]);
    return Command;
}();
export var InfoMessage = /*#__PURE__*/ function() {
    "use strict";
    function InfoMessage(record) {
        _class_call_check(this, InfoMessage);
        _define_property(this, "discriminator", 1);
        _define_property(this, "text", void 0);
        this.text = record.text;
    }
    _create_class(InfoMessage, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return InfoMessage.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                InfoMessage.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return InfoMessage.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link InfoMessage}.
   */ function validateCompatibility(record) {
                BebopTypeGuard.ensureString(record.text);
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link InfoMessage} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new InfoMessage(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link InfoMessage} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("InfoMessage.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                InfoMessage.validateCompatibility(parsed);
                return InfoMessage.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                InfoMessage.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                view.writeString(record.text);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return InfoMessage.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var field0;
                field0 = view.readString();
                var message = {
                    text: field0
                };
                return new InfoMessage(message);
            }
        }
    ]);
    return InfoMessage;
}();
_define_property(InfoMessage, "discriminator", 1);
export var ErrorMessage = /*#__PURE__*/ function() {
    "use strict";
    function ErrorMessage(record) {
        _class_call_check(this, ErrorMessage);
        _define_property(this, "discriminator", 2);
        _define_property(this, "code", void 0);
        _define_property(this, "text", void 0);
        this.code = record.code;
        this.text = record.text;
    }
    _create_class(ErrorMessage, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return ErrorMessage.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                ErrorMessage.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return ErrorMessage.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link ErrorMessage}.
   */ function validateCompatibility(record) {
                BebopTypeGuard.ensureUint8(record.code);
                BebopTypeGuard.ensureString(record.text);
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link ErrorMessage} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new ErrorMessage(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link ErrorMessage} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("ErrorMessage.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                ErrorMessage.validateCompatibility(parsed);
                return ErrorMessage.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                ErrorMessage.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                view.writeByte(record.code);
                view.writeString(record.text);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return ErrorMessage.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var field0;
                field0 = view.readByte();
                var field1;
                field1 = view.readString();
                var message = {
                    code: field0,
                    text: field1
                };
                return new ErrorMessage(message);
            }
        }
    ]);
    return ErrorMessage;
}();
_define_property(ErrorMessage, "discriminator", 2);
export var HelloResponse = /*#__PURE__*/ function() {
    "use strict";
    function HelloResponse(record) {
        _class_call_check(this, HelloResponse);
        _define_property(this, "discriminator", 3);
        _define_property(this, "uid", void 0);
        this.uid = record.uid;
    }
    _create_class(HelloResponse, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return HelloResponse.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                HelloResponse.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return HelloResponse.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link HelloResponse}.
   */ function validateCompatibility(record) {
                BebopTypeGuard.ensureString(record.uid);
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link HelloResponse} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new HelloResponse(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link HelloResponse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("HelloResponse.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                HelloResponse.validateCompatibility(parsed);
                return HelloResponse.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                HelloResponse.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                view.writeString(record.uid);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return HelloResponse.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var field0;
                field0 = view.readString();
                var message = {
                    uid: field0
                };
                return new HelloResponse(message);
            }
        }
    ]);
    return HelloResponse;
}();
_define_property(HelloResponse, "discriminator", 3);
export var SessionDetails = /*#__PURE__*/ function() {
    "use strict";
    function SessionDetails(record) {
        _class_call_check(this, SessionDetails);
        _define_property(this, "discriminator", 4);
        _define_property(this, "id", void 0);
        _define_property(this, "expires", void 0);
        _define_property(this, "members", void 0);
        this.id = record.id;
        this.expires = record.expires;
        this.members = record.members;
    }
    _create_class(SessionDetails, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return SessionDetails.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                SessionDetails.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return SessionDetails.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link SessionDetails}.
   */ function validateCompatibility(record) {
                BebopTypeGuard.ensureString(record.id);
                BebopTypeGuard.ensureDate(record.expires);
                BebopTypeGuard.ensureArray(record.members, SessionMember.validateCompatibility);
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link SessionDetails} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new SessionDetails(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link SessionDetails} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("SessionDetails.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                SessionDetails.validateCompatibility(parsed);
                return SessionDetails.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                SessionDetails.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                view.writeString(record.id);
                view.writeDate(record.expires);
                {
                    var length0 = record.members.length;
                    view.writeUint32(length0);
                    for(var i0 = 0; i0 < length0; i0++){
                        SessionMember.encodeInto(record.members[i0], view);
                    }
                }
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return SessionDetails.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var field0;
                field0 = view.readString();
                var field1;
                field1 = view.readDate();
                var field2;
                {
                    var length0 = view.readUint32();
                    field2 = new Array(length0);
                    for(var i0 = 0; i0 < length0; i0++){
                        var x0 = void 0;
                        x0 = SessionMember.readFrom(view);
                        field2[i0] = x0;
                    }
                }
                var message = {
                    id: field0,
                    expires: field1,
                    members: field2
                };
                return new SessionDetails(message);
            }
        }
    ]);
    return SessionDetails;
}();
_define_property(SessionDetails, "discriminator", 4);
export var CurrentSongVerse = /*#__PURE__*/ function() {
    "use strict";
    function CurrentSongVerse(record) {
        _class_call_check(this, CurrentSongVerse);
        _define_property(this, "discriminator", 5);
        _define_property(this, "songHash", void 0);
        _define_property(this, "verseIdx", void 0);
        this.songHash = record.songHash;
        this.verseIdx = record.verseIdx;
    }
    _create_class(CurrentSongVerse, [
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return CurrentSongVerse.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                CurrentSongVerse.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return CurrentSongVerse.encode(this);
            }
        }
    ], [
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link CurrentSongVerse}.
   */ function validateCompatibility(record) {
                BebopTypeGuard.ensureString(record.songHash);
                BebopTypeGuard.ensureUint8(record.verseIdx);
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link CurrentSongVerse} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                return new CurrentSongVerse(record);
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link CurrentSongVerse} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("CurrentSongVerse.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                CurrentSongVerse.validateCompatibility(parsed);
                return CurrentSongVerse.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                CurrentSongVerse.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                view.writeString(record.songHash);
                view.writeByte(record.verseIdx);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return CurrentSongVerse.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var field0;
                field0 = view.readString();
                var field1;
                field1 = view.readByte();
                var message = {
                    songHash: field0,
                    verseIdx: field1
                };
                return new CurrentSongVerse(message);
            }
        }
    ]);
    return CurrentSongVerse;
}();
_define_property(CurrentSongVerse, "discriminator", 5);
export var Message = /*#__PURE__*/ function() {
    "use strict";
    function Message(data) {
        _class_call_check(this, Message);
        _define_property(this, "data", void 0);
        this.data = data;
    }
    _create_class(Message, [
        {
            key: "discriminator",
            get: function get() {
                return this.data.discriminator;
            }
        },
        {
            key: "value",
            get: function get() {
                return this.data.value;
            }
        },
        {
            key: "isInfoMessage",
            value: function isInfoMessage() {
                return _instanceof(this.data.value, InfoMessage);
            }
        },
        {
            key: "isErrorMessage",
            value: function isErrorMessage() {
                return _instanceof(this.data.value, ErrorMessage);
            }
        },
        {
            key: "isHelloResponse",
            value: function isHelloResponse() {
                return _instanceof(this.data.value, HelloResponse);
            }
        },
        {
            key: "isSessionDetails",
            value: function isSessionDetails() {
                return _instanceof(this.data.value, SessionDetails);
            }
        },
        {
            key: "isCurrentSongVerse",
            value: function isCurrentSongVerse() {
                return _instanceof(this.data.value, CurrentSongVerse);
            }
        },
        {
            key: "stringify",
            value: /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */ function stringify() {
                return Message.encodeToJSON(this);
            }
        },
        {
            key: "validateTypes",
            value: /**
   * Validates that the runtime types of members in the current instance are correct.
   */ function validateTypes() {
                Message.validateCompatibility(this);
            }
        },
        {
            key: "encode",
            value: function encode() {
                return Message.encode(this);
            }
        }
    ], [
        {
            key: "fromInfoMessage",
            value: function fromInfoMessage(value) {
                return new Message({
                    discriminator: 1,
                    value: new InfoMessage(value)
                });
            }
        },
        {
            key: "fromErrorMessage",
            value: function fromErrorMessage(value) {
                return new Message({
                    discriminator: 2,
                    value: new ErrorMessage(value)
                });
            }
        },
        {
            key: "fromHelloResponse",
            value: function fromHelloResponse(value) {
                return new Message({
                    discriminator: 3,
                    value: new HelloResponse(value)
                });
            }
        },
        {
            key: "fromSessionDetails",
            value: function fromSessionDetails(value) {
                return new Message({
                    discriminator: 4,
                    value: new SessionDetails(value)
                });
            }
        },
        {
            key: "fromCurrentSongVerse",
            value: function fromCurrentSongVerse(value) {
                return new Message({
                    discriminator: 5,
                    value: new CurrentSongVerse(value)
                });
            }
        },
        {
            key: "encodeToJSON",
            value: /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */ function encodeToJSON(record) {
                delete record.data.value.discriminator;
                return JSON.stringify(record, BebopJson.replacer);
            }
        },
        {
            key: "validateCompatibility",
            value: /**
   * Validates that the specified dynamic object can become an instance of {@link Message}.
   */ function validateCompatibility(record) {
                var discriminator = record.data.discriminator;
                BebopTypeGuard.ensureUint8(discriminator);
                switch(discriminator){
                    case 1:
                        {
                            InfoMessage.validateCompatibility(record.data.value);
                            break;
                        }
                    case 2:
                        {
                            ErrorMessage.validateCompatibility(record.data.value);
                            break;
                        }
                    case 3:
                        {
                            HelloResponse.validateCompatibility(record.data.value);
                            break;
                        }
                    case 4:
                        {
                            SessionDetails.validateCompatibility(record.data.value);
                            break;
                        }
                    case 5:
                        {
                            CurrentSongVerse.validateCompatibility(record.data.value);
                            break;
                        }
                    default:
                        {
                            throw new Error("Unknown discriminator for Message: ".concat(discriminator));
                        }
                }
            }
        },
        {
            key: "unsafeCast",
            value: /**
   * Unsafely creates an instance of {@link Message} from the specified dynamic object. No type checking is performed.
   */ function unsafeCast(record) {
                var discriminator = record.data.discriminator;
                switch(discriminator){
                    case 1:
                        {
                            return new Message({
                                discriminator: 1,
                                value: InfoMessage.unsafeCast(record.value)
                            });
                        }
                    case 2:
                        {
                            return new Message({
                                discriminator: 2,
                                value: ErrorMessage.unsafeCast(record.value)
                            });
                        }
                    case 3:
                        {
                            return new Message({
                                discriminator: 3,
                                value: HelloResponse.unsafeCast(record.value)
                            });
                        }
                    case 4:
                        {
                            return new Message({
                                discriminator: 4,
                                value: SessionDetails.unsafeCast(record.value)
                            });
                        }
                    case 5:
                        {
                            return new Message({
                                discriminator: 5,
                                value: CurrentSongVerse.unsafeCast(record.value)
                            });
                        }
                }
                throw new BebopRuntimeError("Failed to unsafely cast union from discriminator: ".concat(discriminator));
            }
        },
        {
            key: "fromJSON",
            value: /**
   * Creates a new {@link Message} instance from a JSON-Over-Bebop string. Type checking is performed.
   */ function fromJSON(json) {
                if (typeof json !== 'string' || json.trim().length === 0) {
                    throw new BebopRuntimeError("Message.fromJSON: expected string");
                }
                var parsed = JSON.parse(json, BebopJson.reviver);
                Message.validateCompatibility(parsed);
                return Message.unsafeCast(parsed);
            }
        },
        {
            key: "encode",
            value: function encode(record) {
                var view = BebopView.getInstance();
                view.startWriting();
                Message.encodeInto(record, view);
                return view.toArray();
            }
        },
        {
            key: "encodeInto",
            value: function encodeInto(record, view) {
                var before = view.length;
                var pos = view.reserveMessageLength();
                var start = view.length + 1;
                view.writeByte(record.data.discriminator);
                switch(record.data.discriminator){
                    case 1:
                        InfoMessage.encodeInto(record.data.value, view);
                        break;
                    case 2:
                        ErrorMessage.encodeInto(record.data.value, view);
                        break;
                    case 3:
                        HelloResponse.encodeInto(record.data.value, view);
                        break;
                    case 4:
                        SessionDetails.encodeInto(record.data.value, view);
                        break;
                    case 5:
                        CurrentSongVerse.encodeInto(record.data.value, view);
                        break;
                }
                var end = view.length;
                view.fillMessageLength(pos, end - start);
                var after = view.length;
                return after - before;
            }
        },
        {
            key: "decode",
            value: function decode(buffer) {
                var view = BebopView.getInstance();
                view.startReading(buffer);
                return Message.readFrom(view);
            }
        },
        {
            key: "readFrom",
            value: function readFrom(view) {
                var length = view.readMessageLength();
                var end = view.index + 1 + length;
                switch(view.readByte()){
                    case 1:
                        return this.fromInfoMessage(InfoMessage.readFrom(view));
                    case 2:
                        return this.fromErrorMessage(ErrorMessage.readFrom(view));
                    case 3:
                        return this.fromHelloResponse(HelloResponse.readFrom(view));
                    case 4:
                        return this.fromSessionDetails(SessionDetails.readFrom(view));
                    case 5:
                        return this.fromCurrentSongVerse(CurrentSongVerse.readFrom(view));
                    default:
                        view.index = end;
                        throw new BebopRuntimeError("Unrecognized discriminator while decoding Message");
                }
            }
        }
    ]);
    return Message;
}();


//# sourceMappingURL=schema.js.map